#!/usr/bin/env python

from email.message import EmailMessage
import argcomplete
import argparse
import datetime
import logging
import logging.handlers
import smtplib
import ssl
import sys
from time import sleep


# https://stackoverflow.com/questions/19425736/how-to-redirect-stdout-and-stderr-to-logger-in-python
class LoggerWriter:
    def __init__(self, logfct):
        self.logfct = logfct
        self.buf = []

    def write(self, msg):
        if msg.endswith('\n'):
            self.buf.append(msg.removesuffix('\n'))
            self.logfct(''.join(self.buf))
            self.buf = []
        else:
            self.buf.append(msg)

    def flush(self):
        pass

def exception_checks(e, method, verbose):
    e = e.lower()
    # Perform a manual SMTP module exception check
    if '[ssl: wrong_version_number' in e: # SSL/TLS encryption not supported (this script supports SSLv2 through TLSv1.3)
        if verbose: print("[w] '%s'" % e)
        logging.warning(e)
        print('[w] The server does not support or did not accept the SSL/TLS encrypted messages. This is not uncommon.')
        logging.warning('The server does not support or did not accept the SSL/TLS encrypted messages. This is not uncommon.')
    elif 'relay' in e: # Relay not permitted. That string check could cause false positives.
        if verbose: print("[e] '%s'" % e)
        logging.error(e)
        print('[e] Skipping further SMTP connection attempts to avoid potential blocks as SMTP relay is not permitted regardless of delivery method...')
        logging.error('Skipping further SMTP connection attempts to avoid potential blocks as SMTP relay is not permitted regardless of delivery method...')
        print('[-] This script has completed.')
        logging.info('This script has completed.')
        quit()
    elif '(550,' in e or '(450,' in e or '(551,' in e: # Address rejected
        if verbose: print("[e] '%s'" % e)
        logging.error(e)
        print('[e] Skipping further SMTP connection attempts to avoid potential blocks as a provided address was rejected regardless of delivery method...')
        logging.error('Skipping further SMTP connection attempts to avoid potential blocks as a provided address was rejected regardless of delivery method...')
        print('[-] This script has completed.')
        logging.info('This script has completed.')
        quit()
    elif 'dmarc' in e: # DMARC stopped. That string check could cause false positives.
        if verbose: print("[e] '%s'" % e)
        logging.error(e)
        print('[e] Skipping further SMTP connection attempts to avoid potential blocks as the message was stopped by DMARC regardless of delivery method...')
        logging.error('Skipping further SMTP connection attempts to avoid potential blocks as the message was stopped by DMARC regardless of delivery method...')
        print('[-] This script has completed.')
        logging.info('This script has completed.')
        quit()
    elif '(535,' in e: # Incorrect password
        if verbose: print("[e] '%s'" % e)
        logging.error(e)
        print('[e] Skipping further SMTP connection attempts to avoid a potential lockout...')
        logging.error('Skipping further SMTP connection attempts to avoid a potential lockout...')
        print('[-] This script has completed.')
        logging.info('This script has completed.')
        quit()
    else:
        if verbose: print("[w] '%s'" % e)
        logging.warning(e)
        print('[w] The server does not support or did not accept the %s encrypted messages.' % method)
        logging.warning('The server does not support or did not accept the %s encrypted messages.' % method)


def main():
    # Setup flags. Help page is generated by default
    parser = argparse.ArgumentParser(description='A Python program to send and spoof multipart SMTP messages.')
    sender_args = parser.add_argument_group('sender arguments', 'Arguments related to who is sending the message')
    sender_args.add_argument('-sn', '--subject-note', default='Email test from {{.Server}}:{{.Port}}', help='Subject note of the message')
    sender_args.add_argument('-f', '--from-body', help='From body address', required=True)
    sender_args.add_argument('-fd', '--from-name', help='Ex. ""Last, First" <user@email.com>"')
    sender_args.add_argument('-fh', '--from-header', help='From header address')
    sender_args.add_argument('-sd', '--sender', help='Ex. ""Last, First" <user@email.com>"')
    recipient_args = parser.add_argument_group('recipient arguments', 'Arguments related to who is receiving the message')
    recipient_args.add_argument('-t', '--to-address', help='To address', required=True)
    recipient_args.add_argument('-c', '--cc-address', help='CC address')
    recipient_args.add_argument('-b', '--bcc-address', help='BCC address')
    recipient_args.add_argument('-rp', '--return-path', help='Ex. ""Last, First" <user@email.com>"')
    server_args = parser.add_argument_group('server arguments', 'Arguments related to the SMTP server sending the message')
    server_args.add_argument('-s', '--smtp-server', help='Host address of SMTP server', required=True)
    server_args.add_argument('-p', '--port', type=int, default=25, help='Destination TCP port')
    server_args.add_argument('-lh', '--local-hostname', default=None, help='Local hostname')
    server_args.add_argument('-u', '--username', help='Authentication username')
    server_args.add_argument('-pw', '--password', help='Ex. "Password123!"')
    server_args.add_argument('-hd', '--header', help='Ex. "Header:Value;Header:;"')
    server_args.add_argument('-ti', '--timeout', type=int, default=5, help='Default SMTP server connect timeout')
    server_args.add_argument('-v', '--verbose', action='store_true', help='Enable SMTP verbose/debug mode')
    parser.add_argument('-lf', '--log-file', help='Log filepath and prepend')
    parser.add_argument('--dry-run', action='store_true', help='Print MIME message format to stdout and log file without sending')


    # Organize arguments into their individual arguments
    argcomplete.autocomplete(parser)
    args = parser.parse_args()

    # Convert arguments with spaces from tuple to string to support spaces
    args.subject_note = args.subject_note.replace('{{.Server}}', args.smtp_server)
    args.subject_note = args.subject_note.replace('{{.Port}}', str(args.port))
    args.subject_note = args.subject_note.replace('{{.Email}}', args.to_address)
    if not args.from_header:
        args.subject_note = args.subject_note.replace('{{.From}}', args.from_body)
    else:
        args.subject_note = args.subject_note.replace('{{.From}}', args.from_header)


    # Configure logging settings
    # Create ISO 8061 compliant filename
    log_date = datetime.datetime.utcnow().strftime('%Y%m%dT%H%M%SZ')
    if not args.log_file:
        args.log_file = 'spoof_email_log_' + log_date + '.txt'
    else:
        args.log_file = args.log_file.lstrip("'")
        args.log_file = args.log_file.rstrip("'")
        args.log_file = args.log_file.lstrip('"')
        args.log_file = args.log_file.rstrip('"')
        args.log_file = args.log_file + log_date + '.txt'
    
    logging.basicConfig(format='%(asctime)s %(levelname)-8s %(message)s', level=logging.DEBUG, filename=args.log_file, datefmt='%Y-%m-%dT%H:%M:%SZ', filemode='a')
    logger = logging.getLogger('foobar')
    sys.stderr = LoggerWriter(logger.debug)
    logging.debug('Executing %s...', sys.argv[0]) 
    logging.debug('Variable values:')
    logging.debug('Subject Note = \"%s\"', args.subject_note)
    logging.debug('From Body = \"%s\"', args.from_body)
    logging.debug('From Name = \"%s\"', args.from_name)
    logging.debug('From Header = \"%s\"', args.from_header)
    logging.debug('Sender = \"%s\"', args.sender)
    logging.debug('To Address = \"%s\"', args.to_address)
    logging.debug('CC Address = \"%s\"', args.cc_address)
    logging.debug('BCC Address = \"%s\"', args.bcc_address)
    logging.debug('Return Path = \"%s\"', args.return_path)
    logging.debug('SMTP Server = \"%s\"', args.smtp_server)
    logging.debug('Port = %i', args.port)
    logging.debug('Local Hostname = \"%s\"', args.local_hostname)
    logging.debug('Username = \"%s\"', args.username)
    logging.debug('Header(s) = \"%s\"', args.header)
    logging.debug('Timeout = %i', args.timeout)
    logging.debug('Verbose = \"%s\", 2 means True, 0 means False', args.verbose)
    logging.debug('Log File = \"%s\"', args.log_file)


    # Authentication requires both credentials
    if not args.username and args.password or args.username and not args.password:
        print('[e] Must include a username and password authenticated messages.')
        parser.print_help()
        exit(1)
    
    # Require the proper header format for correct parsing
    if args.header:
        if not args.header[-1] == ';' or ':' not in args.header:
            print('[e] Header must be formatted as "Header:Value;Header:;"')
            parser.print_help()
            exit(1)

    # Get MIME required date format
    msg_date = datetime.datetime.now()
    msg_date = msg_date.strftime('%a, %d %b %Y %H:%M:%S %z')

	# Build message to be sent
    print('[-] Creating message headers...')
    msg = EmailMessage()
    msg['Date'] = msg_date

    # Add subject if requested
    if args.subject_note:
        msg['Subject'] = args.subject_note
    
    # Declare from address in the header based on from_body, from_header, and from_name
    if args.from_body == args.from_header or not args.from_header: # If not spoofing
            if args.from_name:
                msg['From'] = '{} <{}>'.format(args.from_name, args.from_body)
                if args.return_path:
                    msg['Return-Path'] = args.return_path
                else:
                    msg['Return-Path'] = '{} <{}>'.format(args.from_name, args.from_body)
            else:
                msg['From'] = args.from_body
                if args.return_path:
                    msg['Return-Path'] = args.return_path
                else:
                    msg['Return-Path'] = args.from_body
    else:
        if args.from_name:
                msg['From'] = '{} <{}>'.format(args.from_name,args.from_header)
                if args.return_path:
                    msg['Return-Path'] = args.return_path
                else:
                    msg['Return-Path'] = '{} <{}>'.format(args.from_name, args.from_header)
        else:
            msg['From'] = args.from_header
            if args.return_path:
                msg['Return-Path'] = args.return_path
            else:
                msg['Return-Path'] = args.from_header

    if args.header: # Split argument headers by semicolon then colon to declare and define the headers
        for h in args.header.split(';'):
            if h:
                msg[h.split(':')[0]] = h.split(':')[1]

    # Add sender header address
    if args.sender:
        msg['Sender'] = args.sender

    # Add To header address
    msg['To'] = args.to_address

    # Add CC and BCC addresses
    if args.cc_address:
         msg['Cc'] = args.cc_address
    if args.bcc_address:
        msg['Bcc'] = args.bcc_address
    print('[-] Done')

    # Determine if the message is normal or a spoof attempt
    if args.from_body == args.from_header or not args.from_header:
        print('[-] Constructing standard plaintext message body...')
        # Add plaintext message content
        msg.set_content('To: {}\n\
From: {}\n\
Subject: {}\n\
\n\
SMTP email test.\n\
\n\
Mail can be sent using the server at {}:{}\n\
\n\
Address From: {}\n\
Address To: {}\n'.format(args.to_address, args.from_body, args.subject_note, \
args.smtp_server, args.port, args.from_body, args.to_address))
        print('[-] Done')
        print('[-] Constructing standard HTML message body...')
        # Add HTML message content
        msg.add_alternative('\
<html>\n\
<body>\n\
<p>To: {}<br>\n\
From: {}<br>\n\
Subject: {}<br>\n\
<br>\n\
<i>SMTP email test.</i><br>\n\
<br>\n\
Mail can be sent using the server at {}:{}<br>\n\
<br>\n\
Address From: {}<br>\n\
Address To: {}</p><br>\n\
</body>\n\
</html>\n'.format(args.to_address, args.from_body, args.subject_note, \
args.smtp_server, args.port, args.from_body, args.to_address), subtype='html')
        print('[-] Done')
        print('[-] Constructing standard HTML watch message body...')
        # Add HTML watch message content
        msg.add_alternative('\
To: {}\n\
From: {}\n\
Subject: {}\n\
\n\
<u>SMTP email test.</u>\n\
\n\
Mail can be sent using the server at {}:{}\n\
\n\
Address From: {}\n\
Address To: {}\n'.format(args.to_address, args.from_body, args.subject_note, \
args.smtp_server, args.port, args.from_body, args.to_address), subtype='watch-html')
        print('[-] Done')
    else:
        print('[-] Constructing spoofed plaintext message body...')
        # Add plaintext message content
        msg.set_content('\
To: {}\n\
From: {}\n\
Subject: {}\n\
\n\
SMTP email test.\n\
\n\
Mail can be sent using the server at {}:{}\n\
\n\
Header: \n\
Address From: {}\n\
Address To: {}\n\
\n\
Body: \n\
Address From: {}\n\
Address To: {}\n'.format(args.to_address, args.from_body, args.subject_note, \
args.smtp_server, args.port, args.from_header, args.to_address, args.from_body, args.to_address))
        print('[-] Done')
        print('[-] Constructing spoofed HTML message body...')
        # Add HTML message content
        msg.add_alternative('\
<html>\n\
<body>\n\
<p>To: {}<br>\n\
From: {}<br>\n\
Subject: {}<br>\n\
<br>\n\
<i>SMTP email test.</i><br>\n\
<br>\n\
Mail can be sent using the server at {}:{}<br>\n\
<br>\n\
Header: <br>\n\
Address From: {}<br>\n\
Address To: {}<br>\n\
<br>\n\
Body: <br>\n\
Address From: {}<br>\n\
Address To: {}</p><br>\n\
</body>\n\
</html>\n'.format(args.to_address, args.from_body, args.subject_note, args.smtp_server, \
args.port, args.from_header, args.to_address, args.from_body, args.to_address), subtype='html')
        print('[-] Done')
        print('[-] Constructing spoofed HTML watch message body...')
        # Add HTML watch message content
        msg.add_alternative('\
To: {}\n\
From: {}\n\
Subject: {}\n\
\n\
<u>SMTP email test.</u>\n\
\n\
Mail can be sent using the server at {}:{}\n\
\n\
Header: \n\
Address From: {}\n\
Address To: {}\n\
\n\
Body: \n\
Address From: {}\n\
Address To: {}\n'.format(args.to_address, args.from_body, args.subject_note, \
args.smtp_server, args.port, args.from_header, args.to_address, args.from_body, args.to_address), subtype='watch-html')
        print('[-] Done')           

    # According to online research, a straight starttls check can be used as a sslstrip mitm attack.
    # Therefore to mitigate this vulnerability, we check the response code:
    # TODO: https://stackoverflow.com/questions/33857698/sending-email-from-python-using-starttls

    # Furthermore, new STARTTLS vulnerabilities were announced recently which may impact this script:
    # TODO: https://nostarttls.secvuln.info/

    if args.dry_run:
        # Make a local copy of what we are going to send
        print('[i] Writing log to %s...', args.log_file)
        print('######################MIME-DRY-RUN-START######################')
        print(str(msg))
        print('######################MIME-DRY-RUN-END########################')
        print('[-] Done')
    else: 
        # Creates a Python SSL library context to connect over SSL/TLS connections using certain parameters.
        # As of this writing 8/10/2021, ssl.protocol_tls supports SSLv2 through TLSv1.3. This may need updated with future TLS versions.
        context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
        context.check_hostname = False

        # Allows the certificate to have a common name mismatch, self-signed status, or to not exist.
        # ssl.cert_optional was not chosen as it is in client mode which is equivalent to ssl.cert_required which we don't want.
        context.verify_mode = ssl.CERT_NONE

        # This script will attempt in order 1. implicit SSL/TLS, 2. explicit SSL/TLS (starttls), and 3. unencrypted SMTP connections.
        # The idea is method 1 is more likely to pass through a filter than methods 2. or 3. in order.
        # A try catch chain will easily capture and collect the error while continuing to run. A badly designed exception check function
        # was added to stop redundant method checks if our test failed. SMTP error codes are not always consistent. So this will most likely
        # need returned to at a later date. A good example is if in our relay test we fail to relay with implicit SSL/TLS, explicit SSL/TLS,
        # and unencrypted connection methods are going to fail regardless. Therefore, we skip further checks for that specific test.
        try:
            # Test for an implicit SSL/TLS connection
            print('[i] Attempting to send the message using SSL/TLS...')
            logging.info('Attempting to send the message using SSL/TLS...')
            sleep(5) # Added here to avoid rate limiting
            with smtplib.SMTP_SSL(host=args.smtp_server, port=args.port, local_hostname=args.local_hostname, timeout=args.timeout, context=context) as server:
                server.set_debuglevel(1)
                if args.username:
                    server.login(user=args.username, password=args.password)
                server.send_message(msg)
        except Exception as e:
            e = str(e)
            method = 'SSL/TLS'
            exception_checks(e, method, args.verbose)
            try:
                # Test for an explicit SSL/TLS connection
                print('[i] Attempting to send the message using STARTTLS...')
                logging.info('Attempting to send the message using STARTTLS...')
                sleep(6)
                server = smtplib.SMTP(host=args.smtp_server, port=args.port, local_hostname=args.local_hostname, timeout=args.timeout)
                server.set_debuglevel(1)
                server.starttls(context=context)
                if args.username:
                    server.login(user=args.username, password=args.password)
                server.send_message(msg)
            except Exception as e:
                e = str(e)
                method = 'STARTTLS'
                exception_checks(e, method, args.verbose)
                try:
                    # Test for an unencrypted connection
                    print('[i] Attempting to send the message unencrypted...')
                    logging.info('Attempting to send the message unencrypted...')
                    sleep(7)
                    with smtplib.SMTP(host=args.smtp_server, port=args.port, local_hostname=args.local_hostname, timeout=args.timeout) as server:
                        server.set_debuglevel(1)
                        if args.username:
                            server.login(user=args.username, password=args.password)
                        server.send_message(msg)
                except:
                    if args.verbose: print("[w] '%s'" % e)
                    logging.warning(e)
                    print('[w] The server does not support or did not accept the unencrypted message. Therefore, no messages were sent.')
                    logging.warning('The server does not support or did not accept the unencrypted message. Therefore, no messages were sent.')
                else:
                    print('[i] The message was sent unencrypted.')
                    logging.info('The message was sent unencrypted.')
            else:
                print('[i] The message was sent using STARTTLS encryption.')
                logging.info('The message was sent using STARTTLS encryption.')
        else:
            print('[i] The message was sent using SSL/TLS encryption.')
            logging.info('The message was sent using SSL/TLS encryption.')

        # State conclusion and clarity
        print('[i] If any of the above statements said a message was sent, the message could not have been received by the recipient due to the existing email filtering process. This is due to the nature of SMTP and you must contact the recipient to confirm.')
        logging.info('If any of the above statements said a message was sent, the message could not have received by the recipient due to the existing email filtering process. This is due to the nature of SMTP and you must contact the recipient to confirm.')
        print('[-] This script has completed.')
        logging.info('This script has completed.')


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        logging.error('Program termination requested by user')
        print('[e] Program termination requested by user')